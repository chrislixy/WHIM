\documentclass[11pt]{article}


\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{abstract}
This paper presents different algorithms to sample from marginal posterior of variances in random effects model. The marginal posterior is generated by the algorithm provided by Michael Lavine et al (2014).
\end{abstract}

\section{Introduction}

Linear mixed models are an important class of statistical models. It can be presented mathematically as 

\begin{eqnarray*}
y=X \beta + Z u + \epsilon


<<echo=false,results=hide,fig=TRUE>>=

install.packages("devtools")
library(devtools)
install_github("andrewpbray/lmmoptim")
library(lmmoptim)
HMO <- read.csv("~/Documents/2015 Fall Semester/STA 863/Project/HMO.csv")
HMO_states <- read.csv("~/Documents/2015 Fall Semester/STA 863/Project/HMO_states.csv")
hmobig=merge(x = HMO, y = HMO_states, by = "state", all.x = TRUE)

y <- hmobig$indPrem
n <- length(y)
mod <- lm(indPrem ~ expPerAdm + (region == "NE") + state, data = hmobig, x = TRUE)
x <- mod$x[, 1:3]
z <- mod$x[, -(1:3), drop = FALSE]
SigE <- diag(n)
SigS <- diag(44)

linesA <- findlines(x, z, y, SigE, SigS)
mlreboxA <- with(linesA,
                 makebox(lims.sigsqs = c(0, max(int.sigsqs[is.finite(int.sigsqs)])),
                         lims.sigsqe = c(0, max(int.sigsqe[is.finite(int.sigsqe)])),
                         status = rep("straddle", nrow(linesA)),
                         lines = linesA))
boxes.HH11 <- findf(lines = linesA, mlreboxA, eps = 5, delE = log(10), 
                     delS = log(10), ratio = TRUE, M = 5, maxit = 10)

p <- showboxes(boxes.HH11)
p + scale_x_continuous(name = expression(sigma[e]^2)) +
    scale_y_continuous(name = expression(sigma[s]^2)) +
    theme_bw()

p <- showfunc(boxes.HH11)
p + scale_x_log10(name = expression(sigma[e]^2),
                  breaks = c(100,300,1000,3000,10000)) +
    scale_y_log10(name = expression(sigma[s]^2),
                  breaks = c(30,100,300,1000,3000,10000)) +
    theme_bw()
@

\Section{Rejection Sampler}

With the 

<<echo=false,results=hide,fig=TRUE>>=
# initial setup
N = 10000 # total samples wanted

rj=function(n,boxes){
  # with uniform envelop function
  e=runif(n,min(boxes$sigsqe.lo),max(boxes$sigsqe.hi))
  s=runif(n,min(boxes$sigsqs.lo),max(boxes$sigsqs.hi))
  d=NULL
  for (i in 1:length(e)){
    d[i]=boxes$rll.lower[which(e[i]>=boxes$sigsqe.lo & e[i]<=boxes$sigsqe.hi & s[i]>=boxes$sigsqs.lo & s[i]<=boxes$sigsqs.hi)]
  }
  U=runif(n)
  tmp=(d-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))/(max(boxes$rll.lower)-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))
  tmp[tmp==-Inf]=0
  accept=data.frame(sige=e[U<tmp],sigs=s[U<tmp])
  return(accept)
}


a=function(N){
rejection=rj(N,boxes.HH11)
while (dim(rejection)[1]<N) {
  n=(N*1.2-dim(rejection)[1])*N/dim(rejection)[1]
  rejection=rbind(rejection,rj(n))
  print(n)
  print(dim(rejection)[1])
}
rejection=rejection[1:N,]}

system.time(a(N))

library(hexbin)
plot(hexbin(rejection),xlab=expression(sigma[e]^2),ylab=expression(sigma[s]^2))
@


<<echo=false,results=hide,fig=TRUE>>=

rj2=function(n,boxes){
  # with normal envelop function
  library(mvtnorm)
  coor=rmvt(n,
               delta=c((boxes$sigsqe.lo[which.max(boxes$rll.lower)]+boxes$sigsqe.lo[which.max(boxes$rll.upper)])/2,(boxes$sigsqs.lo[which.max(boxes$rll.lower)]+boxes$sigsqs.lo[which.max(boxes$rll.upper)])/2), 
  sigma=diag(c((max(boxes$sigsqe.hi)-boxes$sigsqe.lo[which.max(boxes$rll.upper)])/3,(max(boxes$sigsqs.hi)-boxes$sigsqs.lo[which.max(boxes$rll.upper)])/3)))
  newdata=coor[(coor[,1]>=0 & coor[,1]<=max(boxes$sigsqe.hi) & coor[,2]>=0) & coor[,2]<=max(boxes$sigsqs.hi),]
  e=newdata[,1]
  s=newdata[,2]
  d=NULL
  for (i in 1:length(e)){
    d[i]=boxes$rll.lower[which(e[i]>=boxes$sigsqe.lo & e[i]<=boxes$sigsqe.hi & s[i]>=boxes$sigsqs.lo & s[i]<=boxes$sigsqs.hi)]
  }
  U=runif(length(e))
  tmp=(d-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))/(max(boxes$rll.lower)-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))
  tmp[tmp==-Inf]=0
  accept=data.frame(sige=e[U<tmp],sigs=s[U<tmp])
  return(accept)
}
b=function(N){
rejection=rj2(N,boxes.HH11)
while (dim(rejection)[1]<N) {
  n=(N*1.2-dim(rejection)[1])*N/dim(rejection)[1]
  rejection=rbind(rejection,rj2(n,boxes.HH11))
  print(n)
  print(dim(rejection)[1])
}
rejection=rejection[1:N,]}
system.time(b(N))

library(hexbin)
plot(hexbin(rejection),xlab=expression(sigma[e]^2),ylab=expression(sigma[s]^2))

@



<<>>=

Mhmo=boxes.HH11
Mhmo$tmp=660000*(dnorm(Mhmo$sigsqe.lo,6000,1000)+dnorm(Mhmo$sigsqs.lo,6000,1000))
Mhmo$rll.lower=Mhmo$rll.lower+Mhmo$tmp
Mhmo$rll.upper=Mhmo$rll.upper+Mhmo$tmp
Mhmo=as.data.frame(Mhmo)


p <- showfunc(Mhmo)
p + scale_x_log10(name = expression(sigma[e]^2),
                  breaks = c(100,300,1000,3000,10000)) +
    scale_y_log10(name = expression(sigma[s]^2),
                  breaks = c(30,100,300,1000,3000,10000)) +
    theme_bw()




a=function(N,Mhmo){
rejection=rj(N,Mhmo)
while (dim(rejection)[1]<N) {
  n=(N*1.2-dim(rejection)[1])*N/dim(rejection)[1]
  rejection=rbind(rejection,rj(n,Mhmo))
  print(n)
  print(dim(rejection)[1])
}
rejection=rejection[1:N,]}

rejection=rj(N,Mhmo)
while (dim(rejection)[1]<N) {
  n=(N*1.2-dim(rejection)[1])*N/dim(rejection)[1]
  rejection=rbind(rejection,rj(n,Mhmo))
}
rejection=rejection[1:N,]
system.time(a(N,Mhmo))

par(log="x", xlog=TRUE)
plot(hexbin(rejection),xlab=expression(sigma[e]^2),ylab=expression(sigma[s]^2))
@


<<>>=

center=matrix(c(282,1094,6000,6000),ncol=2,byrow=T)
var=array(c(500,100,100,500,1000,0,0,1000),dim=c(2,2,2))  
rj2=function(n,boxes,center,var,prob){
  # with normal envelop function
  library(mvtnorm)
  components <- sample(length(prob),prob=prob,size=n,replace=TRUE)
  mus <- center
  sds <- var
  coor=matrix(0,ncol=2,nrow=n)
  for (i in 1:n){coor[i,]=rmvt(1,delta=mus[components[i],],sigma=sds[,,components[i]])}
  newdata=coor[(coor[,1]>=0 & coor[,1]<=max(boxes$sigsqe.hi) & coor[,2]>=0) & coor[,2]<=max(boxes$sigsqs.hi),]
  e=newdata[,1]
  s=newdata[,2]
  d=NULL
  for (i in 1:length(e)){
    d[i]=boxes$rll.lower[which(e[i]>=boxes$sigsqe.lo & e[i]<=boxes$sigsqe.hi & s[i]>=boxes$sigsqs.lo & s[i]<=boxes$sigsqs.hi)]
  }
  U=runif(length(e))
  tmp=(d-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))/(max(boxes$rll.lower)-min(boxes$rll.lower[boxes$rll.lower!=-Inf]))
  tmp[tmp==-Inf]=0
  accept=data.frame(sige=e[U<tmp],sigs=s[U<tmp])
  return(accept)
}
b=function(N){
rejection=rj2(N,boxes=Mhmo,center=center,var=var,prob=c(0.3,0.7))
while (dim(rejection)[1]<N) {
  n=(N*1.2-dim(rejection)[1])*N/dim(rejection)[1]
  rejection=rbind(rejection,rj2(n,boxes=Mhmo,center=center,var=var,prob=c(0.3,0.7)))
  print(n)
  print(dim(rejection)[1])
}
rejection=rejection[1:N,]
}
system.time(b(N))

plot(hexbin(rejection),xlab=expression(sigma[e]^2),ylab=expression(sigma[s]^2))


@

\end{document}